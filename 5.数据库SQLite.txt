1.MySQL常用存储引擎
  1.InnoDB是MySQL的默认存储引擎，支持事务、表锁\行锁和外键等操作,数据和索引是集中存储的
  2.MyISAM是MySQL 5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁粒度为表级锁,数据和索引是分开存储的

2.三大范式
第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值
第二范式：确保表中的每列都和主键相关
第三范式：确保每列都和主键列直接相关而不是间接相关

3.MySQL数据类型
1.整数
2.浮点数
3.字符串
4.日期

4.索引
  索引是一种用于快速查询和检索数据的数据结构 ，常见的索引结构有: B 树， B+树和 Hash。
  索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

5.索引的种类:
  主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引
  组合索引：由多个列值组成的索引。
  唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值 的组合必须唯一。
  全文索引：对文本的内容进行搜索。
  普通索引：基本的索引类型，可以为NULL

6.什么是聚簇索引，什么是非聚簇索引？
    聚簇索引和非聚簇索引最主要的区别是数据和索引是否分开存储。
    聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。
    非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址 。
    在InnoDB存储引擎中，默认的索引为B+树索引，**利用主键创建的索引为主索引，也是聚簇索引，在主 索引之上创建的索引为辅助索引，也是非聚簇索引。**为什么说辅助索引是在主索引之上创建的呢，因为 辅助索引中的叶子节点存储的是主键。
    在MyISAM存储引擎中，默认的索引也是B+树索引，但主索引和辅助索引都是非聚簇索引，也就是说索 引结构的叶子节点存储的都是一个指向数据行的地址。并且使用辅助索引检索无需访问主键的索引。

7.事务
  事务是逻辑上的一组操作，要么都执行，要么都不执行。

8.事务的四大特性（ACID）是什么？
  原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。
  一致性：一致性指事务在执行前后状态是一致的。
  隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。
  持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。

9.数据库的并发一致性问题
    当多个事务并发执行时，可能会出现以下问题：
    脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚 了，事务B读取到的数据就成为脏数据了。
    不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交 了，导致事务A多次读取到的数据并不一致。
    幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时 发现多了几条数据，和之前读取的数据不一致。
    丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改 覆盖了事务A的修改。
    不可重复度和幻读看起来比较像，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被 更新了。在幻读中，发现数据不一致主要是数据增多或者减少了。

10.数据库的隔离级别有哪些？
    READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
    READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
    REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


11.什么是死锁？如何避免？
    死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现 象。在MySQL中,MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。 在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。

12.为什么要分库分表？
    分表
    比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。
    分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。
    分库
    分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。
    这就是所谓的分库分表。

13.什么是垂直分表、垂直分库、水平分表、水平分库？
      垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个 表中，将不常用的字段放到另一个表中。
      垂直分表的优势：
      避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二， 大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。 可
      以更好地提升热门数据的查询效率。
      垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上 面。
      垂直分库的优势：
      降低业务中的耦合，方便对不同的业务进行分级管理。
      可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题。
      垂直拆分（分库、分表）的缺点：
      主键出现冗余，需要管理冗余列
      事务的处理变得复杂
      仍然存在单表数据量过大的问题
      水平分表：在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。
      水平分表的优势：
      解决了单表数据量过大的问题
      避免IO竞争并减少锁表的概率
      水平分库：把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务 器上。
      水平分库的优势：
      解决了单库大数据量的瓶颈问题
      IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳 定性和可用性
      水平拆分（分表、分库）的缺点：
      分片事务一致性难以解决
      跨节点JOIN性能差，逻辑会变得复杂
      数据扩展难度大，不易维护
      在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑 缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较 复杂，常见的方案有客户端架构和恶代理架构。
      分库分表后，ID键如何处理？
      分库分表后不能每个表的ID都是从1开始，所以需要一个全局ID，设置全局ID主要有以下几种方法：
      UUID：优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合作为 索引。
      数据库自增ID：在分库分表表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接 收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库 分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈。系统结构如下图
      Redis生成ID：优点：不依赖数据库，性能比较好。缺点：引入新的组件会使得系统复杂度增加
      Twitter的snowflake算法：是一个64位的long型的ID，其中有1bit是不用的，41bit作为毫秒数， 10bit作为工作机器ID，12bit作为序列号。 1bit：第一个bit默认为0，因为二进制中第一个bit为1的话为负数，但是ID不能为负数. 41bit：表示的是时间戳，单位是毫秒。 10bit：记录工作机器ID，其中5个bit表示机房ID，5个bit表示机器ID。 12bit：用来记录同一毫秒内产生的不同ID。

14.主从复制的作用：
    高可用和故障转移
    负载均衡
    数据备份
    升级测试

15.了解读写分离吗？
    读写分离主要依赖于主从复制，主从复制为读写分离服务。
    读写分离的优势：
    主服务器负责写，从服务器负责读，缓解了锁的竞争
    从服务器可以使用MyISAM，提升查询性能及节约系统开销
    增加冗余，提高可用性

16.SQLite数据类型：

17.事务的4个特性：
1.原子性
2.一致性
3.隔离性
4.持久性
  说一说事务的4个特性
  原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。重点是操作！
  一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。重点是数据！
  隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。
  持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

18.ER图：

19.索引的类型：
  普通索引：加速查询
  组合（联合）索引：加速查询
  唯一索引：建议使用hash，InnoDB中可以有多个null，可以加速查询，列值唯一
  主键索引：不能为null，列值唯一，表中只有一个
  全文索引：对文本内容分词，进行搜索（只有MyISAM引擎支持）

20.MySQL那ACID靠什么保证的？
  A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
  C一致性一般由代码层面来保证
  I隔离性由MVCC来保证
  D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复
  